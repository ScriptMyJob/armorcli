#!/usr/bin/env python
# Written by:   Robert J.
#               Robert@scriptmyjob.com

import armor_auth

import sys
import json
import os

#######################################
##### Global Variables ################
#######################################

arguments = {
    "support": {
        "_desc":                "Display from under the Support Tab",
        "create_ticket": {
            "_desc":            "Opens a support ticket",
            "_function":        "support.open_ticket(baseurl, headers, ticket_title, first_comment)",
            "ticket_tile":      "This is required for the creation of a ticket (see below for example)",
            "first_comment":    "This is also required for the creation of a ticket (see below for example)",
        },
        "get_tickets": {
            "_desc":            "Returns a list of user tickets",
            "_function":        "support.get_tickets(baseurl, headers)",
            "ticketsList":      "Returns list of tickets only."
        },
        "get_ticket_count": {
            "_desc":            "Returns a count of tickets that the user has ",
            "_function":        "support.get_ticket_count(baseurl, headers)",
            "N/A":              "There is no subcommand for this argument"
        }
    },
    "security": {
        "_desc":                "Display from under the Security Tab",
        "placehoder": {
            "_desc":            "Placeholder",
            "_function":        "Placeholder",
            "subplaceholder":   "Placeholder"
        }
    },
    "infrastructure": {
        "_desc":                "Display from under the Infrastructure Tab",
        "list_vms": {
            "_desc":            "Returns a list of VMs",
            "_function": "infrastructure.get_vm_list(baseurl, headers)",
            "coreInstanceId":   "Returns a list of all core instance ids",
            "cpu":              "Returns a list of CPU counts",
            "dateCreated":      "Returns a list of creation dates",
            "externalAddress":  "Returns a list of Public IP addresses",
            "ipAddress":        "Returns a list of Internal IP addresses",
            "location":         "Returns a list of locations",
            "memory":           "Returns a list of Memory Resources",
            "name":             "Returns a list of VM Names",
            "operatingSystem":  "Returns a list of OSs",
            "product":          "Returns a list of dicts for product info",
            "tags":             "Returns a list of list of tags",
            "vmId":             "Returns a list of VM IDs",
            "workLoadName":     "Returns a list of Workloads (PODs)",
            "zone":             "Returns a list of Zones"
        },
        "list_apps": {
            "_desc":            "Returns a list of Workloads",
            "_function": "infrastructure.get_app_list(baseurl, headers)",
            "id":               "Returns a list of Workload IDs",
            "location":         "Returns a list of Workload locations",
            "name":             "Returns a list of Workload names",
            "vmCount":          "Returns a list of Workload VM Counts",
            "zone":             "Returns a list of Workload vCenters"
        }
    },
    "account": {
        "_desc":                "Display from under the Account Tab",
        "user_info": {
            "_desc":            "Returns information about the current user",
            "_function": "account.get_user_info(baseurl, headers)",
            "accounts":         "Returns accounts associated with the current user",
            "features":         "Returns features associated with the current user",
            "permissions":      "Returns permissions associated with the current user",
            "user":             "Returns user info associated with the current user"
        },
        "armor_contacts": {
            "_desc":                    "Returns a list of Armor contacts",
            "_function":                "account.get_armor_contacts(baseurl, headers)",
            "accountStrategicManager":  "Returns account 'Strategic Manager'",
            "accountExecutive":         "Returns account 'Executive'"
        },
        "association": {
            "_desc":        "Returns a list of associated accounts for the current user",
            "_function":    "account.get_associated(baseurl, headers)",
            "id":           "Returns a list of associated account ids",
            "name":         "Returns a list of associated account names",
            "products":     "Returns a list of dicts containing products",
            "status":       "Returns a list of account statuses"
        },
        "info": {
            "_desc":        "Returns information about the current account",
            "_function":    "account.get_account_info(baseurl, headers, account_id)",
            "accountId":    "Returns the current account id",
            "name":         "Returns the current account name"
        }
    }
}

DEBUG   = os.environ.get('Debug', None)

#######################################
### Main Function #####################
#######################################

def main():
    syntax_check()
    account_id, baseurl, token = armor_auth.main()

    headers = {
        "Accept": "application/json",
        "Authorization": "FH-AUTH " + token,
        "X-Account-Context": str(account_id)
    }

    debug("Headers: ", headers)

    out = parse_args(account_id, baseurl, headers)

    debug('OUT -<< EOF')
    print_out(out)
    debug('EOF')


#######################################
### Program Specific Functions ########
#######################################

def debug(message, variable=None):
    if variable and DEBUG:
        if isinstance(variable, list) or isinstance(variable, dict):
            print("\n" + str(type(variable)))
            variable = json.dumps(
                variable,
                indent=4,
                sort_keys=True
            )

    if DEBUG:
        if variable:
            print(message + str(variable) + "\n")
        else:
            print("\n" + message)


def parse_args(account_id, baseurl, headers):
    options = arguments.keys()

    try:
        option = sys.argv[1]
        command = sys.argv[2]
    except IndexError:
        print('Invalid')

    if option in options:
        commands = arguments[option].keys()
        commands.remove('_desc')
        if command in commands:
            icommand = arguments[option][command]['_function']

    out = compile_and_exec(icommand, account_id, baseurl, headers)

    try:
        return out
    except UnboundLocalError:
        invalid()


def compile_and_exec(icommand, account_id, baseurl, headers):
    if sys.argv[2] == 'create_ticket':
        code = compile(
            'import infrastructure;' +
            'import account;' +
            'import support;' +
            'account_id = "' + str(account_id) + '";' +
            'baseurl = "' + baseurl + '";' +
            'headers = ' + str(headers) + ';' +
            'ticket_title = "' + sys.argv[3] + '";' +
            'first_comment = "' + sys.argv[4] + '";' +
            'out = ' + icommand,
            '<string>',
            'exec'
        )
    else:
        code = compile(
            'import infrastructure;' +
            'import account;' +
            'import support;' +
            'account_id = "' + str(account_id) + '";' +
            'baseurl = "' + baseurl + '";' +
            'headers = ' + str(headers) + ';' +
            'out = ' + icommand,
            '<string>',
            'exec'
        )

    ns = {}
    exec(code) in ns

    return ns['out']


def print_out(out):
    if len(sys.argv) == 4:
        if isinstance(out, list):
            out = [l[sys.argv[3]] for l in out]
        else:
            out = out[sys.argv[3]]

    print(
        json.dumps(
            out,
            indent=4,
            sort_keys=True
        )
    )


def syntax_check():
    debug("Checking syntax.")

    if len(sys.argv) < 3:
        invalid(1)
    if sys.argv[1] not in arguments.keys():
        invalid(2)

    debug("Passed dummy check.")


def invalid(code=255):
    print("Invalid syntax:")
    print_help()
    sys.exit(code)


def print_help():
    script = __file__.split('/')[-1]
    options = arguments.keys()

    header('Useage')

    main_args = arguments.keys()
    print(script + " [options] [command] <subcommand>")

    header('Options')
    for m in sorted(options):
        print(
            '{:4}'.format(' ') +
            '{:<15}'.format(m) +
            '{:6}'.format(' ') +
            arguments[m]["_desc"]
        )

    header('Commands')
    for m in sorted(options):
        print("{:4}".format(' ') + m)
        commands = arguments[m].keys()
        commands.remove('_desc')

        for c in sorted(commands):
            print(
                '{:8}'.format(' ') +
                '{:<15}'.format(c) +
                '{:2}'.format(' ') +
                arguments[m][c]['_desc']
            )

    header('Subcommands')
    for m in sorted(main_args):
        print("{:4}".format(' ') + m)
        commands = arguments[m].keys()
        commands.remove('_desc')

        for c in sorted(commands):
            print('{:8}'.format(' ') + c)
            subcommands = arguments[m][c].keys()
            subcommands.remove('_desc')
            subcommands.remove('_function')

            for s in sorted(subcommands):
                print(
                    '{:12}'.format(' ') +
                    '{:<15}'.format(s) +
                    '{:2}'.format(' ') +
                    arguments[m][c][s]
                )

def header(message):
    print("\n" + message + ":" + "\n" + '-' * (len(message) + 1))


#######################################
##### Execution #######################
#######################################

if __name__ == "__main__":
    main()
